// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: articles.sql

package sqlc

import (
	"context"
	"time"
)

const addArticleTag = `-- name: AddArticleTag :exec
INSERT OR IGNORE INTO article_tags (article_id, tag_id) VALUES (?, ?)
`

type AddArticleTagParams struct {
	ArticleID *string `json:"article_id"`
	TagID     *int64  `json:"tag_id"`
}

func (q *Queries) AddArticleTag(ctx context.Context, arg AddArticleTagParams) error {
	_, err := q.db.ExecContext(ctx, addArticleTag, arg.ArticleID, arg.TagID)
	return err
}

const countArticles = `-- name: CountArticles :one
SELECT COUNT(*) FROM articles
`

func (q *Queries) CountArticles(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countArticles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createArticle = `-- name: CreateArticle :exec
INSERT INTO articles (
    id, title, content, summary,
    source_type, source_url, author, published_at, language,
    created_at, updated_at, status,
    source_id, parent_id, sections, custom_metadata
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateArticleParams struct {
	ID             string     `json:"id"`
	Title          string     `json:"title"`
	Content        string     `json:"content"`
	Summary        *string    `json:"summary"`
	SourceType     *string    `json:"source_type"`
	SourceUrl      *string    `json:"source_url"`
	Author         *string    `json:"author"`
	PublishedAt    *time.Time `json:"published_at"`
	Language       *string    `json:"language"`
	CreatedAt      time.Time  `json:"created_at"`
	UpdatedAt      time.Time  `json:"updated_at"`
	Status         *string    `json:"status"`
	SourceID       *string    `json:"source_id"`
	ParentID       *string    `json:"parent_id"`
	Sections       *string    `json:"sections"`
	CustomMetadata *string    `json:"custom_metadata"`
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) error {
	_, err := q.db.ExecContext(ctx, createArticle,
		arg.ID,
		arg.Title,
		arg.Content,
		arg.Summary,
		arg.SourceType,
		arg.SourceUrl,
		arg.Author,
		arg.PublishedAt,
		arg.Language,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.SourceID,
		arg.ParentID,
		arg.Sections,
		arg.CustomMetadata,
	)
	return err
}

const deleteArticle = `-- name: DeleteArticle :exec
DELETE FROM articles WHERE id = ?
`

func (q *Queries) DeleteArticle(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteArticle, id)
	return err
}

const deleteArticleFTS = `-- name: DeleteArticleFTS :exec
DELETE FROM articles_fts WHERE article_id = ?
`

func (q *Queries) DeleteArticleFTS(ctx context.Context, articleID string) error {
	_, err := q.db.ExecContext(ctx, deleteArticleFTS, articleID)
	return err
}

const deleteArticlesBySourceID = `-- name: DeleteArticlesBySourceID :exec
DELETE FROM articles WHERE source_id = ?
`

func (q *Queries) DeleteArticlesBySourceID(ctx context.Context, sourceID *string) error {
	_, err := q.db.ExecContext(ctx, deleteArticlesBySourceID, sourceID)
	return err
}

const getArticleByID = `-- name: GetArticleByID :one
SELECT id, title, content, summary,
    source_type, source_url, author, published_at, language,
    created_at, updated_at, status,
    source_id, parent_id, sections, custom_metadata
FROM articles WHERE id = ?
`

func (q *Queries) GetArticleByID(ctx context.Context, id string) (Article, error) {
	row := q.db.QueryRowContext(ctx, getArticleByID, id)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Summary,
		&i.SourceType,
		&i.SourceUrl,
		&i.Author,
		&i.PublishedAt,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.SourceID,
		&i.ParentID,
		&i.Sections,
		&i.CustomMetadata,
	)
	return i, err
}

const getArticleTags = `-- name: GetArticleTags :many
SELECT t.id, t.name, t.color, t.created_at
FROM tags t
JOIN article_tags at ON t.id = at.tag_id
WHERE at.article_id = ?
`

func (q *Queries) GetArticleTags(ctx context.Context, articleID *string) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getArticleTags, articleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticlesBySourceID = `-- name: GetArticlesBySourceID :many
SELECT id, title, content, summary,
    source_type, source_url, author, published_at, language,
    created_at, updated_at, status,
    source_id, parent_id, sections, custom_metadata
FROM articles WHERE source_id = ?
`

func (q *Queries) GetArticlesBySourceID(ctx context.Context, sourceID *string) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, getArticlesBySourceID, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Summary,
			&i.SourceType,
			&i.SourceUrl,
			&i.Author,
			&i.PublishedAt,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.SourceID,
			&i.ParentID,
			&i.Sections,
			&i.CustomMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertArticleFTS = `-- name: InsertArticleFTS :exec
INSERT INTO articles_fts (article_id, title, content, summary)
VALUES (?, ?, ?, ?)
`

type InsertArticleFTSParams struct {
	ArticleID string `json:"article_id"`
	Title     string `json:"title"`
	Content   string `json:"content"`
	Summary   string `json:"summary"`
}

func (q *Queries) InsertArticleFTS(ctx context.Context, arg InsertArticleFTSParams) error {
	_, err := q.db.ExecContext(ctx, insertArticleFTS,
		arg.ArticleID,
		arg.Title,
		arg.Content,
		arg.Summary,
	)
	return err
}

const listArticlesAll = `-- name: ListArticlesAll :many
SELECT id, title, content, summary,
    source_type, source_url, author, published_at, language,
    created_at, updated_at, status,
    source_id, parent_id, sections, custom_metadata
FROM articles
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListArticlesAllParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListArticlesAll(ctx context.Context, arg ListArticlesAllParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listArticlesAll, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Summary,
			&i.SourceType,
			&i.SourceUrl,
			&i.Author,
			&i.PublishedAt,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.SourceID,
			&i.ParentID,
			&i.Sections,
			&i.CustomMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesBySourceType = `-- name: ListArticlesBySourceType :many
SELECT id, title, content, summary,
    source_type, source_url, author, published_at, language,
    created_at, updated_at, status,
    source_id, parent_id, sections, custom_metadata
FROM articles
WHERE source_type = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListArticlesBySourceTypeParams struct {
	SourceType *string `json:"source_type"`
	Limit      int64   `json:"limit"`
	Offset     int64   `json:"offset"`
}

func (q *Queries) ListArticlesBySourceType(ctx context.Context, arg ListArticlesBySourceTypeParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listArticlesBySourceType, arg.SourceType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Summary,
			&i.SourceType,
			&i.SourceUrl,
			&i.Author,
			&i.PublishedAt,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.SourceID,
			&i.ParentID,
			&i.Sections,
			&i.CustomMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesByStatus = `-- name: ListArticlesByStatus :many
SELECT id, title, content, summary,
    source_type, source_url, author, published_at, language,
    created_at, updated_at, status,
    source_id, parent_id, sections, custom_metadata
FROM articles
WHERE status = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListArticlesByStatusParams struct {
	Status *string `json:"status"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
}

func (q *Queries) ListArticlesByStatus(ctx context.Context, arg ListArticlesByStatusParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listArticlesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Summary,
			&i.SourceType,
			&i.SourceUrl,
			&i.Author,
			&i.PublishedAt,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.SourceID,
			&i.ParentID,
			&i.Sections,
			&i.CustomMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesByStatusAndSourceType = `-- name: ListArticlesByStatusAndSourceType :many
SELECT id, title, content, summary,
    source_type, source_url, author, published_at, language,
    created_at, updated_at, status,
    source_id, parent_id, sections, custom_metadata
FROM articles
WHERE status = ? AND source_type = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListArticlesByStatusAndSourceTypeParams struct {
	Status     *string `json:"status"`
	SourceType *string `json:"source_type"`
	Limit      int64   `json:"limit"`
	Offset     int64   `json:"offset"`
}

func (q *Queries) ListArticlesByStatusAndSourceType(ctx context.Context, arg ListArticlesByStatusAndSourceTypeParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listArticlesByStatusAndSourceType,
		arg.Status,
		arg.SourceType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Summary,
			&i.SourceType,
			&i.SourceUrl,
			&i.Author,
			&i.PublishedAt,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.SourceID,
			&i.ParentID,
			&i.Sections,
			&i.CustomMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeArticleTag = `-- name: RemoveArticleTag :exec
DELETE FROM article_tags WHERE article_id = ? AND tag_id = ?
`

type RemoveArticleTagParams struct {
	ArticleID *string `json:"article_id"`
	TagID     *int64  `json:"tag_id"`
}

func (q *Queries) RemoveArticleTag(ctx context.Context, arg RemoveArticleTagParams) error {
	_, err := q.db.ExecContext(ctx, removeArticleTag, arg.ArticleID, arg.TagID)
	return err
}

const searchArticlesLike = `-- name: SearchArticlesLike :many
SELECT id, title, content, summary,
    source_type, source_url, author, published_at, language,
    created_at, updated_at, status,
    source_id, parent_id, sections, custom_metadata
FROM articles
WHERE title LIKE ? OR content LIKE ?
ORDER BY created_at DESC
LIMIT ?
`

type SearchArticlesLikeParams struct {
	Title   string `json:"title"`
	Content string `json:"content"`
	Limit   int64  `json:"limit"`
}

func (q *Queries) SearchArticlesLike(ctx context.Context, arg SearchArticlesLikeParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, searchArticlesLike, arg.Title, arg.Content, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Summary,
			&i.SourceType,
			&i.SourceUrl,
			&i.Author,
			&i.PublishedAt,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.SourceID,
			&i.ParentID,
			&i.Sections,
			&i.CustomMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArticle = `-- name: UpdateArticle :exec
UPDATE articles SET
    title = ?, content = ?, summary = ?,
    source_type = ?, source_url = ?, author = ?, published_at = ?, language = ?,
    updated_at = ?, status = ?,
    source_id = ?, parent_id = ?, sections = ?, custom_metadata = ?
WHERE id = ?
`

type UpdateArticleParams struct {
	Title          string     `json:"title"`
	Content        string     `json:"content"`
	Summary        *string    `json:"summary"`
	SourceType     *string    `json:"source_type"`
	SourceUrl      *string    `json:"source_url"`
	Author         *string    `json:"author"`
	PublishedAt    *time.Time `json:"published_at"`
	Language       *string    `json:"language"`
	UpdatedAt      time.Time  `json:"updated_at"`
	Status         *string    `json:"status"`
	SourceID       *string    `json:"source_id"`
	ParentID       *string    `json:"parent_id"`
	Sections       *string    `json:"sections"`
	CustomMetadata *string    `json:"custom_metadata"`
	ID             string     `json:"id"`
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) error {
	_, err := q.db.ExecContext(ctx, updateArticle,
		arg.Title,
		arg.Content,
		arg.Summary,
		arg.SourceType,
		arg.SourceUrl,
		arg.Author,
		arg.PublishedAt,
		arg.Language,
		arg.UpdatedAt,
		arg.Status,
		arg.SourceID,
		arg.ParentID,
		arg.Sections,
		arg.CustomMetadata,
		arg.ID,
	)
	return err
}
