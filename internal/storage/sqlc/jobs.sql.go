// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package sqlc

import (
	"context"
	"time"
)

const cleanupCompletedJobs = `-- name: CleanupCompletedJobs :execrows
DELETE FROM processing_jobs
WHERE status = 'completed' AND completed_at < ?
`

func (q *Queries) CleanupCompletedJobs(ctx context.Context, completedAt *time.Time) (int64, error) {
	result, err := q.db.ExecContext(ctx, cleanupCompletedJobs, completedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const completeJob = `-- name: CompleteJob :exec
UPDATE processing_jobs
SET status = 'completed', progress = 100, current_step = NULL, completed_at = ?
WHERE id = ?
`

type CompleteJobParams struct {
	CompletedAt *time.Time `json:"completed_at"`
	ID          string     `json:"id"`
}

func (q *Queries) CompleteJob(ctx context.Context, arg CompleteJobParams) error {
	_, err := q.db.ExecContext(ctx, completeJob, arg.CompletedAt, arg.ID)
	return err
}

const countJobsByStatus = `-- name: CountJobsByStatus :many
SELECT status, COUNT(*) as count FROM processing_jobs GROUP BY status
`

type CountJobsByStatusRow struct {
	Status *string `json:"status"`
	Count  int64   `json:"count"`
}

func (q *Queries) CountJobsByStatus(ctx context.Context) ([]CountJobsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, countJobsByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountJobsByStatusRow{}
	for rows.Next() {
		var i CountJobsByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createJob = `-- name: CreateJob :exec
INSERT INTO processing_jobs (
    id, source_id, type, status, priority, progress, current_step,
    retry_count, error, created_at, started_at, completed_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateJobParams struct {
	ID          string     `json:"id"`
	SourceID    *string    `json:"source_id"`
	Type        string     `json:"type"`
	Status      *string    `json:"status"`
	Priority    *int64     `json:"priority"`
	Progress    *int64     `json:"progress"`
	CurrentStep *string    `json:"current_step"`
	RetryCount  *int64     `json:"retry_count"`
	Error       *string    `json:"error"`
	CreatedAt   time.Time  `json:"created_at"`
	StartedAt   *time.Time `json:"started_at"`
	CompletedAt *time.Time `json:"completed_at"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) error {
	_, err := q.db.ExecContext(ctx, createJob,
		arg.ID,
		arg.SourceID,
		arg.Type,
		arg.Status,
		arg.Priority,
		arg.Progress,
		arg.CurrentStep,
		arg.RetryCount,
		arg.Error,
		arg.CreatedAt,
		arg.StartedAt,
		arg.CompletedAt,
	)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM processing_jobs WHERE id = ?
`

func (q *Queries) DeleteJob(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteJob, id)
	return err
}

const failJob = `-- name: FailJob :exec
UPDATE processing_jobs
SET status = 'failed', error = ?, completed_at = ?
WHERE id = ?
`

type FailJobParams struct {
	Error       *string    `json:"error"`
	CompletedAt *time.Time `json:"completed_at"`
	ID          string     `json:"id"`
}

func (q *Queries) FailJob(ctx context.Context, arg FailJobParams) error {
	_, err := q.db.ExecContext(ctx, failJob, arg.Error, arg.CompletedAt, arg.ID)
	return err
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, source_id, type, status, priority, progress, current_step,
    retry_count, error, created_at, started_at, completed_at
FROM processing_jobs WHERE id = ?
`

func (q *Queries) GetJobByID(ctx context.Context, id string) (ProcessingJob, error) {
	row := q.db.QueryRowContext(ctx, getJobByID, id)
	var i ProcessingJob
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.Type,
		&i.Status,
		&i.Priority,
		&i.Progress,
		&i.CurrentStep,
		&i.RetryCount,
		&i.Error,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getJobsBySourceID = `-- name: GetJobsBySourceID :many
SELECT id, source_id, type, status, priority, progress, current_step,
    retry_count, error, created_at, started_at, completed_at
FROM processing_jobs
WHERE source_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetJobsBySourceID(ctx context.Context, sourceID *string) ([]ProcessingJob, error) {
	rows, err := q.db.QueryContext(ctx, getJobsBySourceID, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessingJob{}
	for rows.Next() {
		var i ProcessingJob
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.Type,
			&i.Status,
			&i.Priority,
			&i.Progress,
			&i.CurrentStep,
			&i.RetryCount,
			&i.Error,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextQueuedJob = `-- name: GetNextQueuedJob :one
SELECT id, source_id, type, status, priority, progress, current_step,
    retry_count, error, created_at, started_at, completed_at
FROM processing_jobs
WHERE status = 'queued'
ORDER BY priority ASC, created_at ASC
LIMIT 1
`

func (q *Queries) GetNextQueuedJob(ctx context.Context) (ProcessingJob, error) {
	row := q.db.QueryRowContext(ctx, getNextQueuedJob)
	var i ProcessingJob
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.Type,
		&i.Status,
		&i.Priority,
		&i.Progress,
		&i.CurrentStep,
		&i.RetryCount,
		&i.Error,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listJobsByStatus = `-- name: ListJobsByStatus :many
SELECT id, source_id, type, status, priority, progress, current_step,
    retry_count, error, created_at, started_at, completed_at
FROM processing_jobs
WHERE status = ?
ORDER BY priority ASC, created_at ASC
LIMIT ?
`

type ListJobsByStatusParams struct {
	Status *string `json:"status"`
	Limit  int64   `json:"limit"`
}

func (q *Queries) ListJobsByStatus(ctx context.Context, arg ListJobsByStatusParams) ([]ProcessingJob, error) {
	rows, err := q.db.QueryContext(ctx, listJobsByStatus, arg.Status, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessingJob{}
	for rows.Next() {
		var i ProcessingJob
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.Type,
			&i.Status,
			&i.Priority,
			&i.Progress,
			&i.CurrentStep,
			&i.RetryCount,
			&i.Error,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentJobs = `-- name: ListRecentJobs :many
SELECT id, source_id, type, status, priority, progress, current_step,
    retry_count, error, created_at, started_at, completed_at
FROM processing_jobs
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) ListRecentJobs(ctx context.Context, limit int64) ([]ProcessingJob, error) {
	rows, err := q.db.QueryContext(ctx, listRecentJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessingJob{}
	for rows.Next() {
		var i ProcessingJob
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.Type,
			&i.Status,
			&i.Priority,
			&i.Progress,
			&i.CurrentStep,
			&i.RetryCount,
			&i.Error,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retryJob = `-- name: RetryJob :exec
UPDATE processing_jobs
SET status = 'queued', retry_count = retry_count + 1, error = NULL, current_step = NULL
WHERE id = ?
`

func (q *Queries) RetryJob(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, retryJob, id)
	return err
}

const startJob = `-- name: StartJob :exec
UPDATE processing_jobs
SET status = 'running', started_at = ?
WHERE id = ?
`

type StartJobParams struct {
	StartedAt *time.Time `json:"started_at"`
	ID        string     `json:"id"`
}

func (q *Queries) StartJob(ctx context.Context, arg StartJobParams) error {
	_, err := q.db.ExecContext(ctx, startJob, arg.StartedAt, arg.ID)
	return err
}

const updateJobProgress = `-- name: UpdateJobProgress :exec
UPDATE processing_jobs SET progress = ? WHERE id = ?
`

type UpdateJobProgressParams struct {
	Progress *int64 `json:"progress"`
	ID       string `json:"id"`
}

func (q *Queries) UpdateJobProgress(ctx context.Context, arg UpdateJobProgressParams) error {
	_, err := q.db.ExecContext(ctx, updateJobProgress, arg.Progress, arg.ID)
	return err
}

const updateJobProgressWithStep = `-- name: UpdateJobProgressWithStep :exec
UPDATE processing_jobs SET progress = ?, current_step = ? WHERE id = ?
`

type UpdateJobProgressWithStepParams struct {
	Progress    *int64  `json:"progress"`
	CurrentStep *string `json:"current_step"`
	ID          string  `json:"id"`
}

func (q *Queries) UpdateJobProgressWithStep(ctx context.Context, arg UpdateJobProgressWithStepParams) error {
	_, err := q.db.ExecContext(ctx, updateJobProgressWithStep, arg.Progress, arg.CurrentStep, arg.ID)
	return err
}
